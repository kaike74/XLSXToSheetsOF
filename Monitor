// Sistema de monitoramento e mÃ©tricas de performance
const MONITOR = {
  startTime: null,
  checkpoints: [],
  errors: [],
  stats: {
    recordsProcessed: 0,
    recordsSuccessful: 0,
    apiCalls: 0,
    cacheHits: 0,
    totalTime: 0
  }
};

// Inicializar monitoramento
function startMonitoring() {
  MONITOR.startTime = Date.now();
  MONITOR.checkpoints = [];
  MONITOR.errors = [];
  MONITOR.stats = {
    recordsProcessed: 0,
    recordsSuccessful: 0,
    apiCalls: 0,
    cacheHits: 0,
    totalTime: 0
  };
  
  Logger.log("ğŸ“Š Monitoramento iniciado");
}

// Adicionar checkpoint
function addCheckpoint(name, details = '') {
  if (!MONITOR.startTime) {
    startMonitoring();
  }
  
  const now = Date.now();
  const checkpoint = {
    name: name,
    time: now,
    elapsed: now - MONITOR.startTime,
    details: details
  };
  
  MONITOR.checkpoints.push(checkpoint);
  Logger.log(`â±ï¸ ${name}: ${checkpoint.elapsed}ms ${details}`);
}

// Registrar erro
function logError(context, error) {
  const errorInfo = {
    context: context,
    error: error.toString(),
    time: Date.now(),
    elapsed: MONITOR.startTime ? Date.now() - MONITOR.startTime : 0
  };
  
  MONITOR.errors.push(errorInfo);
  Logger.log(`âŒ [${context}] ${error}`);
}

// Atualizar estatÃ­sticas
function updateStats(stat, increment = 1) {
  if (MONITOR.stats.hasOwnProperty(stat)) {
    MONITOR.stats[stat] += increment;
  }
}

// RelatÃ³rio final
function generateReport() {
  if (!MONITOR.startTime) {
    Logger.log("ğŸ“Š Nenhum monitoramento ativo");
    return;
  }
  
  const totalTime = Date.now() - MONITOR.startTime;
  MONITOR.stats.totalTime = totalTime;
  
  Logger.log("=== RELATÃ“RIO DE PERFORMANCE ===");
  Logger.log(`â±ï¸ Tempo total: ${(totalTime/1000).toFixed(2)}s`);
  Logger.log(`ğŸ“Š Registros processados: ${MONITOR.stats.recordsProcessed}`);
  Logger.log(`âœ… Registros bem-sucedidos: ${MONITOR.stats.recordsSuccessful}`);
  Logger.log(`ğŸ“ Chamadas Ã  API: ${MONITOR.stats.apiCalls}`);
  Logger.log(`ğŸ’¾ Cache hits: ${MONITOR.stats.cacheHits}`);
  
  if (MONITOR.stats.recordsProcessed > 0) {
    const successRate = (MONITOR.stats.recordsSuccessful / MONITOR.stats.recordsProcessed * 100).toFixed(1);
    const avgTime = (totalTime / MONITOR.stats.recordsProcessed).toFixed(0);
    const recordsPerSecond = (MONITOR.stats.recordsProcessed / (totalTime/1000)).toFixed(1);
    
    Logger.log(`ğŸ¯ Taxa de sucesso: ${successRate}%`);
    Logger.log(`âš¡ Tempo mÃ©dio por registro: ${avgTime}ms`);
    Logger.log(`ğŸš€ Registros por segundo: ${recordsPerSecond}`);
  }
  
  if (MONITOR.errors.length > 0) {
    Logger.log(`âŒ Total de erros: ${MONITOR.errors.length}`);
    Logger.log("--- PRIMEIROS 5 ERROS ---");
    MONITOR.errors.slice(0, 5).forEach((err, i) => {
      Logger.log(`${i+1}. [${err.context}] ${err.error} (${err.elapsed}ms)`);
    });
  }
  
  if (MONITOR.checkpoints.length > 0) {
    Logger.log("--- CHECKPOINTS PRINCIPAIS ---");
    MONITOR.checkpoints.slice(-10).forEach(cp => {
      Logger.log(`${cp.name}: ${cp.elapsed}ms ${cp.details}`);
    });
  }
  
  Logger.log("===============================");
}

// Monitoramento em tempo real
function realtimeStatus() {
  if (!MONITOR.startTime) {
    Logger.log("ğŸ“Š Monitoramento nÃ£o iniciado");
    return;
  }
  
  const elapsed = Date.now() - MONITOR.startTime;
  const currentRate = MONITOR.stats.recordsProcessed > 0 ? 
    (MONITOR.stats.recordsProcessed / (elapsed/1000)).toFixed(1) : '0';
  
  Logger.log(`ğŸ”„ Status: ${MONITOR.stats.recordsProcessed} registros | ${(elapsed/1000).toFixed(1)}s | ${currentRate} rec/s`);
  
  return {
    elapsed: elapsed,
    recordsProcessed: MONITOR.stats.recordsProcessed,
    recordsPerSecond: parseFloat(currentRate),
    errors: MONITOR.errors.length
  };
}

// FunÃ§Ã£o para monitorar a exportaÃ§Ã£o principal
function monitoredImport() {
  try {
    startMonitoring();
    addCheckpoint("InÃ­cio da importaÃ§Ã£o");
    
    // Executar funÃ§Ã£o principal
    importXLSXDataToGoogleSheetsAndExportToNotion();
    
    addCheckpoint("ImportaÃ§Ã£o concluÃ­da");
    generateReport();
    
  } catch (error) {
    logError("Processo principal", error);
    generateReport();
    throw error;
  }
}

// Teste de conectividade
function testConnectivity() {
  Logger.log("ğŸ”Œ Testando conectividade...");
  
  const tests = [
    {
      name: "Google Drive",
      test: () => DriveApp.getFileById(CONFIG.fileId).getName()
    },
    {
      name: "Google Sheets",
      test: () => SpreadsheetApp.openById(CONFIG.destinationSheetId).getName()
    },
    {
      name: "Notion API",
      test: () => {
        const response = UrlFetchApp.fetch(`https://api.notion.com/v1/users/me`, {
          method: "get",
          headers: {
            "Authorization": `Bearer ${CONFIG.NOTION_TOKEN_1}`,
            "Notion-Version": "2022-06-28"
          },
          muteHttpExceptions: true
        });
        return response.getResponseCode() === 200;
      }
    }
  ];
  
  let allPassed = true;
  
  tests.forEach(test => {
    try {
      const result = test.test();
      Logger.log(`âœ… ${test.name}: OK`);
    } catch (error) {
      Logger.log(`âŒ ${test.name}: ERRO - ${error}`);
      allPassed = false;
    }
  });
  
  if (allPassed) {
    Logger.log("ğŸ¯ Todos os testes de conectividade passaram");
  } else {
    Logger.log("âš ï¸ Alguns testes falharam - verifique as configuraÃ§Ãµes");
  }
  
  return allPassed;
}

// Estimativa de tempo restante
function estimateTimeRemaining(totalRecords, processedRecords, elapsedTime) {
  if (processedRecords === 0) return "Calculando...";
  
  const recordsRemaining = totalRecords - processedRecords;
  const avgTimePerRecord = elapsedTime / processedRecords;
  const estimatedRemaining = recordsRemaining * avgTimePerRecord;
  
  const minutes = Math.floor(estimatedRemaining / 60000);
  const seconds = Math.floor((estimatedRemaining % 60000) / 1000);
  
  return `${minutes}m ${seconds}s`;
}

// Dashboard simples
function showDashboard() {
  Logger.log("=== DASHBOARD ===");
  
  if (processedValues) {
    Logger.log(`ğŸ“Š Dados carregados: ${processedValues.length - 1} registros`);
    
    if (MONITOR.startTime) {
      const status = realtimeStatus();
      const totalRecords = processedValues.length - 1;
      const remaining = estimateTimeRemaining(totalRecords, status.recordsProcessed, status.elapsed);
      
      Logger.log(`â±ï¸ Tempo decorrido: ${(status.elapsed/1000).toFixed(1)}s`);
      Logger.log(`ğŸ“ˆ Progresso: ${status.recordsProcessed}/${totalRecords} (${((status.recordsProcessed/totalRecords)*100).toFixed(1)}%)`);
      Logger.log(`ğŸš€ Velocidade: ${status.recordsPerSecond} registros/segundo`);
      Logger.log(`â° Tempo estimado restante: ${remaining}`);
      Logger.log(`âŒ Erros: ${status.errors}`);
    }
  } else {
    Logger.log("ğŸ“Š Nenhum dado carregado ainda");
  }
  
  // Status do cache
  const cacheStatus = {
    fileIds: CACHE.fileIds.size,
    processedUrls: CACHE.processedUrls.size,
    dbProperties: NOTION_CACHE.dbProperties.size,
    dbSchemas: NOTION_CACHE.dbSchemas.size
  };
  
  Logger.log(`ğŸ’¾ Status do cache:`);
  Object.entries(cacheStatus).forEach(([key, value]) => {
    Logger.log(`   ${key}: ${value} entradas`);
  });
  
  Logger.log("================");
}

// FunÃ§Ã£o para limpar logs antigos (opcional)
function clearLogs() {
  console.clear();
  Logger.log("ğŸ§¹ Logs limpos");
}

// Benchmark comparativo
function benchmarkOperations() {
  Logger.log("ğŸƒâ€â™‚ï¸ Iniciando benchmark...");
  
  const operations = [
    {
      name: "CriaÃ§Ã£o de 100 URLs de imagem",
      fn: () => {
        const testRow = ['test', '1', '2', '3', '4', '5', '6', '7', 'TestRadio', '100.1', 'Rock', 'M', 'A', '25-44', '1000', '30', '500'];
        for (let i = 0; i < 100; i++) {
          createImage(testRow, 16);
        }
      }
    },
    {
      name: "Processamento de 100 textos",
      fn: () => {
        for (let i = 0; i < 100; i++) {
          const text = `Texto de teste nÃºmero ${i} com conteÃºdo extenso para verificar performance`;
          removeEspacosExtras(text);
          truncateText(text, 50);
        }
      }
    },
    {
      name: "100 operaÃ§Ãµes de cache",
      fn: () => {
        for (let i = 0; i < 100; i++) {
          CACHE.processedUrls.set(`test-${i}`, `value-${i}`);
          CACHE.processedUrls.get(`test-${i}`);
        }
      }
    }
  ];
  
  operations.forEach(op => {
    const start = Date.now();
    try {
      op.fn();
      const time = Date.now() - start;
      Logger.log(`âš¡ ${op.name}: ${time}ms`);
    } catch (error) {
      Logger.log(`âŒ ${op.name}: ERRO`);
    }
  });
  
  Logger.log("ğŸ Benchmark concluÃ­do");
}

// FunÃ§Ã£o para parar monitoramento de emergÃªncia
function emergencyStop() {
  Logger.log("ğŸ›‘ PARADA DE EMERGÃŠNCIA ACIONADA");
  
  if (MONITOR.startTime) {
    generateReport();
  }
  
  // Limpar operaÃ§Ãµes pendentes (se possÃ­vel)
  try {
    clearProcessCacheTurbo();
    Logger.log("ğŸ§¹ Cache limpo");
  } catch (error) {
    Logger.log(`âš ï¸ Erro ao limpar cache: ${error}`);
  }
  
  Logger.log("ğŸ›‘ Sistema parado");
}
