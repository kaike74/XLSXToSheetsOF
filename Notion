// Cache global otimizado para performance m√°xima
const NOTION_CACHE = {
  dbProperties: new Map(),
  dbSchemas: new Map(),
  pageCache: new Map()
};

// Configura√ß√µes otimizadas da API Notion
const NOTION_CONFIG = {
  headers: {
    "Content-Type": "application/json",
    "Notion-Version": "2022-06-28"
  },
  baseUrl: "https://api.notion.com/v1",
  maxBatchSize: 10,
  maxRetries: 2,
  baseDelay: 100
};

// PAGE_CACHE j√° est√° declarado no arquivo "Editar P√°gina"

// FUN√á√ÉO OTIMIZADA PARA ATUALIZA√á√ÉO DE P√ÅGINAS (que estava faltando!)
function updatePageNameAndIconOptimized(pageId, values, token) {
  if (!pageId || !values || !token) {
    Logger.log("‚ö†Ô∏è Par√¢metros inv√°lidos para update de p√°gina");
    return false;
  }

  try {
    // Preparar dados
    const cleanName = removeEspacosExtras(values[34]) || 'Sem nome';
    const timestamp = dateTimeFunction();
    const title = `${cleanName} (${timestamp})`;
    
    const clientUrl = values[32];
    let iconUrl = null;
    
    if (clientUrl) {
      if (PAGE_CACHE.icons.has(clientUrl)) {
        iconUrl = PAGE_CACHE.icons.get(clientUrl);
      } else {
        iconUrl = createPageIcon(clientUrl);
        if (iconUrl) {
          PAGE_CACHE.icons.set(clientUrl, iconUrl);
        }
      }
    }

    const payload = {
      properties: {
        title: [{
          text: { content: title }
        }]
      }
    };
    
    if (iconUrl) {
      payload.icon = {
        type: "external",
        external: { url: iconUrl }
      };
    }

    const response = UrlFetchApp.fetch(`${NOTION_CONFIG.baseUrl}/pages/${pageId}`, {
      method: "PATCH",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28"
      },
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });

    if (response.getResponseCode() === 200) {
      Logger.log(`‚úÖ P√°gina ${pageId} atualizada: ${title}`);
      return true;
    } else {
      Logger.log(`‚ö†Ô∏è Erro ao atualizar p√°gina ${pageId}: ${response.getContentText()}`);
      return false;
    }

  } catch (error) {
    Logger.log(`‚ùå Erro ao atualizar p√°gina ${pageId}: ${error}`);
    return false;
  }
}

// FUN√á√ïES PARA L√ìGICA DOS VALORES DE SPOT E TESTIMONIAL - VERS√ÉO CORRETA!
function propertieSpotTableValue(row, tableIndex, negotiatedIndex) {
  const tableValue = parseFloat(row[tableIndex]) || 0;
  const negotiatedValue = parseFloat(row[negotiatedIndex]) || 0;
  
  // L√ìGICA COMERCIAL CORRETA:
  // Se tabela < negociado OU tabela vazio/zero ‚Üí tabela = negociado (evita "desconto negativo")
  // Se tabela >= negociado ‚Üí tabela fica igual (mostra desconto real)
  let correctedTableValue = tableValue;
  
  if (tableValue === 0 || tableValue < negotiatedValue) {
    correctedTableValue = negotiatedValue;  // Corrige para n√£o mostrar desconto negativo
  }
  // Sen√£o mant√©m tableValue para mostrar desconto real
  
  return { number: correctedTableValue || null };
}

function propertieTestimonialTableValue(row, tableIndex, negotiatedIndex) {
  const tableValue = parseFloat(row[tableIndex]) || 0;
  const negotiatedValue = parseFloat(row[negotiatedIndex]) || 0;
  
  // L√ìGICA COMERCIAL CORRETA:
  // Se tabela < negociado OU tabela vazio/zero ‚Üí tabela = negociado (evita "desconto negativo")
  // Se tabela >= negociado ‚Üí tabela fica igual (mostra desconto real)
  let correctedTableValue = tableValue;
  
  if (tableValue === 0 || tableValue < negotiatedValue) {
    correctedTableValue = negotiatedValue;  // Corrige para n√£o mostrar desconto negativo
  }
  // Sen√£o mant√©m tableValue para mostrar desconto real
  
  return { number: correctedTableValue || null };
}

// FUN√á√ÉO DRASTICAMENTE OTIMIZADA - Limpeza super r√°pida
function clearNotionDatabase(token, databaseId) {
  const queryUrl = `${NOTION_CONFIG.baseUrl}/databases/${databaseId}/query`;
  const headers = {
    ...NOTION_CONFIG.headers,
    "Authorization": `Bearer ${token}`
  };

  try {
    Logger.log("üöÄ Iniciando limpeza otimizada do database...");

    // Buscar todas as p√°ginas de uma s√≥ vez (aumentando page_size)
    let allPages = [];
    let hasMore = true;
    let nextCursor = null;

    while (hasMore) {
      const queryPayload = { page_size: 100 };
      if (nextCursor) {
        queryPayload.start_cursor = nextCursor;
      }

      const queryResponse = UrlFetchApp.fetch(queryUrl, {
        method: "post",
        headers: headers,
        payload: JSON.stringify(queryPayload),
        muteHttpExceptions: true
      });

      if (queryResponse.getResponseCode() !== 200) {
        Logger.log(`‚ùå Erro ao consultar database: ${queryResponse.getContentText()}`);
        return false;
      }

      const data = JSON.parse(queryResponse.getContentText());
      allPages = allPages.concat(data.results);
      
      hasMore = data.has_more;
      nextCursor = data.next_cursor;
      
      // Delay m√≠nimo
      if (hasMore) {
        Utilities.sleep(50);
      }
    }
    
    if (allPages.length === 0) {
      Logger.log("‚úÖ Database j√° est√° vazio");
      return true;
    }

    Logger.log(`üî• Arquivando ${allPages.length} p√°ginas em modo TURBO...`);

    // PROCESSAMENTO SUPER OTIMIZADO - Lotes grandes, delays m√≠nimos
    const batchSize = 15; // Aumentado para m√°xima velocidade
    let archivedCount = 0;

    // Preparar todos os requests de uma vez
    const requests = allPages.map(page => ({
      url: `${NOTION_CONFIG.baseUrl}/pages/${page.id}`,
      options: {
        method: "patch",
        headers: headers,
        payload: JSON.stringify({ archived: true }),
        muteHttpExceptions: true
      }
    }));

    // Processar em lotes super r√°pidos
    for (let i = 0; i < requests.length; i += batchSize) {
      const batch = requests.slice(i, i + batchSize);
      
      // Executar lote em paralelo usando Promise-like approach
      const responses = batch.map(req => {
        try {
          return UrlFetchApp.fetch(req.url, req.options);
        } catch (error) {
          Logger.log(`Erro em request: ${error}`);
          return null;
        }
      });
      
      // Contar sucessos
      responses.forEach(response => {
        if (response && response.getResponseCode() === 200) {
          archivedCount++;
        }
      });

      // Delay m√≠nimo entre lotes
      if (i + batchSize < requests.length) {
        Utilities.sleep(30); // Reduzido drasticamente
      }

      // Log de progresso otimizado
      if (i % (batchSize * 5) === 0) {
        Logger.log(`‚ö° Processadas: ${Math.min(i + batchSize, requests.length)}/${requests.length}`);
      }
    }

    Logger.log(`‚úÖ Limpeza TURBO conclu√≠da: ${archivedCount}/${allPages.length} p√°ginas`);
    return archivedCount > (allPages.length * 0.9); // 90% de sucesso √© aceit√°vel

  } catch (error) {
    Logger.log(`‚ùå Erro cr√≠tico: ${error}`);
    return false;
  }
}

// FUN√á√ÉO SUPER OTIMIZADA - Exporta√ß√£o em massa
function exportDataToNotion(data, token, databaseId, url) {
  const headers = data[0];
  const exportType = data[1][33];

  Logger.log(`üöÄ Iniciando exporta√ß√£o TURBO de ${data.length - 1} registros`);

  // Pre-cache TUDO de uma vez
  const cachePromises = [];
  if (exportType === "M√≠dia Avulsa") {
    cachePromises.push(getNotionDatabaseProperties(databaseId, token));
  } else if (exportType === "Patroc√≠nio") {
    cachePromises.push(getNotionDatabasePropertiesFull(databaseId, token));
  }

  // PROCESSAMENTO PARALELO M√ÅXIMO
  const batchSize = NOTION_CONFIG.maxBatchSize; // 10 registros por vez
  const batches = [];
  
  for (let i = 1; i < data.length; i += batchSize) {
    batches.push(data.slice(i, i + batchSize));
  }

  let processedCount = 0;
  let successCount = 0;
  
  batches.forEach((batch, batchIndex) => {
    const startTime = Date.now();
    
    // Preparar todos os payloads do lote de uma vez
    const payloads = batch.map((row, rowIndex) => {
      try {
        if (exportType === "M√≠dia Avulsa") {
          return preparePayloadSingleMedia(row, token, databaseId, headers);
        } else if (exportType === "Patroc√≠nio") {
          return preparePayloadSponsorship(row, token, databaseId, headers);
        }
      } catch (error) {
        Logger.log(`Erro ao preparar payload: ${error}`);
        return null;
      }
    }).filter(p => p !== null);

    // Enviar lote completo em paralelo
    const responses = payloads.map(payload => {
      try {
        const response = UrlFetchApp.fetch(url, {
          method: "post",
          headers: {
            ...NOTION_CONFIG.headers,
            "Authorization": `Bearer ${token}`
          },
          payload: JSON.stringify(payload),
          muteHttpExceptions: true
        });

        if (response.getResponseCode() < 400) {
          successCount++;
          return JSON.parse(response.getContentText());
        }
        return null;
      } catch (error) {
        Logger.log(`Erro no envio: ${error}`);
        return null;
      }
    });

    processedCount += batch.length;
    
    // CONTE√öDO EXTRA AGORA SUPER SIMPLIFICADO - Apenas embed de r√°dio (se houver)
    responses.forEach((response, index) => {
      if (response && response.id) {
        try {
          addRadioEmbedOnly(response.id, token, batch[index]);
        } catch (error) {
          Logger.log(`Erro no embed de r√°dio: ${error}`);
        }
      }
    });
    
    // Delay m√≠nimo entre lotes
    if (batchIndex < batches.length - 1) {
      Utilities.sleep(NOTION_CONFIG.baseDelay);
    }
    
    const batchTime = (Date.now() - startTime) / 1000;
    Logger.log(`‚ö° Lote ${batchIndex + 1}/${batches.length} | ${processedCount}/${data.length - 1} | ${successCount} sucessos | ${batchTime.toFixed(1)}s`);
  });

  const successRate = ((successCount / (data.length - 1)) * 100).toFixed(1);
  Logger.log(`üéØ CONCLU√çDO: ${successCount}/${data.length - 1} (${successRate}%) registros exportados`);
}

// FUN√á√ïES DE PREPARA√á√ÉO OTIMIZADAS
function preparePayloadSingleMedia(row, token, databaseId, headers) {
  const iconUrl = createImage(row, 27);
  const coverUrl = row[31] ? createImage(row, 31) : iconUrl;
  const dbProps = getNotionDatabaseProperties(databaseId, token);
  const properties = buildPropertiesSingleMedia(row, dbProps);

  return {
    parent: { database_id: databaseId },
    cover: { type: "external", external: { url: coverUrl } },
    icon: { type: "external", external: { url: iconUrl } },
    properties: properties
  };
}

function preparePayloadSponsorship(row, token, databaseId, headers) {
  const iconUrl = createImage(row, 27);
  const coverUrl = row[31] ? createImage(row, 31) : iconUrl;
  const schema = getNotionDatabasePropertiesFull(databaseId, token);
  const properties = buildPropertiesSponsorship(row, headers, schema);

  return {
    parent: { database_id: databaseId },
    cover: { type: "external", external: { url: coverUrl } },
    icon: { type: "external", external: { url: iconUrl } },
    properties: properties
  };
}

// NOVA FUN√á√ÉO SUPER SIMPLIFICADA - Apenas embed de r√°dio
function addRadioEmbedOnly(pageId, token, row) {
  // Agora s√≥ adiciona embed de r√°dio se existir
  if (!row[35] || !row[35].includes("apption.co")) {
    return; // N√£o h√° nada para adicionar
  }

  const urlApi = `${NOTION_CONFIG.baseUrl}/blocks/${pageId}/children`;
  
  try {
    UrlFetchApp.fetch(urlApi, {
      method: "patch",
      headers: {
        ...NOTION_CONFIG.headers,
        "Authorization": `Bearer ${token}`
      },
      payload: JSON.stringify({
        children: [{
          type: "embed",
          embed: { url: row[35] }
        }]
      }),
      muteHttpExceptions: true
    });
  } catch (error) {
    Logger.log(`Erro ao adicionar embed de r√°dio: ${error}`);
  }
}

// FUN√á√ïES AUXILIARES PARA LINKS FORMATADOS
function createMediaKitLink(row) {
  if (!row[28]) return null;
  
  const fileName = row[28].split("/").pop();
  const fileId = getFileIdByName(fileName);
  
  if (!fileId) return null;
  
  const driveUrl = `https://drive.google.com/file/d/${fileId}/view?usp=drive_link`;
  
  return {
    rich_text: [{
      type: "text",
      text: {
        content: "Acesse o M√≠dia Kit",
        link: { url: driveUrl }
      },
      annotations: {
        bold: true,
        color: "blue"
      }
    }]
  };
}

function createFacebookLink(row) {
  if (!row[29]) return null;
  
  const socialMediaParametro = processSocialMediaLink(row[29], row);
  if (!socialMediaParametro) return null;
  
  const facebookUrl = `https://www.facebook.com/${socialMediaParametro}`;
  
  return {
    rich_text: [{
      type: "text",
      text: {
        content: `facebook.com/${socialMediaParametro}`,
        link: { url: facebookUrl }
      },
      annotations: {
        bold: true,
        color: "blue" // Cor azul do Facebook
      }
    }]
  };
}

function createInstagramLink(row) {
  if (!row[30]) return null;
  
  const socialMediaParametro = processSocialMediaLink(row[30], row);
  if (!socialMediaParametro) return null;
  
  const instagramUrl = `https://www.instagram.com/${socialMediaParametro}`;
  
  return {
    rich_text: [{
      type: "text",
      text: {
        content: `@${socialMediaParametro}`,
        link: { url: instagramUrl }
      },
      annotations: {
        bold: true,
        color: "pink" // Cor rosa do Instagram
      }
    }]
  };
}

function createTargetProperty(row) {
  const targetValue = row[42];
  if (!targetValue || String(targetValue).trim() === "") {
    return { rich_text: [{ text: { content: "" } }] };
  }
  
  return {
    rich_text: [{
      text: { content: truncateText(String(targetValue), 2000) },
      annotations: { bold: false }
    }]
  };
}

// Fun√ß√µes auxiliares otimizadas (mantendo funcionalidade)
function getNotionDatabaseProperties(databaseId, token) {
  if (NOTION_CACHE.dbProperties.has(databaseId)) {
    return NOTION_CACHE.dbProperties.get(databaseId);
  }

  try {
    const response = UrlFetchApp.fetch(`${NOTION_CONFIG.baseUrl}/databases/${databaseId}`, {
      method: "get",
      headers: {
        ...NOTION_CONFIG.headers,
        "Authorization": `Bearer ${token}`
      },
      muteHttpExceptions: true
    });

    const data = JSON.parse(response.getContentText());
    const properties = data.properties ? Object.keys(data.properties) : [];
    
    NOTION_CACHE.dbProperties.set(databaseId, properties);
    return properties;
  } catch (error) {
    Logger.log(`Erro ao buscar propriedades: ${error}`);
    return [];
  }
}

function getNotionDatabasePropertiesFull(databaseId, token) {
  if (NOTION_CACHE.dbSchemas.has(databaseId)) {
    return NOTION_CACHE.dbSchemas.get(databaseId);
  }

  try {
    const response = UrlFetchApp.fetch(`${NOTION_CONFIG.baseUrl}/databases/${databaseId}`, {
      method: "get",
      headers: {
        ...NOTION_CONFIG.headers,
        "Authorization": `Bearer ${token}`
      }
    });

    const data = JSON.parse(response.getContentText());
    if (data.properties) {
      NOTION_CACHE.dbSchemas.set(databaseId, data.properties);
      return data.properties;
    }
    return {};
  } catch (error) {
    Logger.log(`Erro ao buscar schema: ${error}`);
    return {};
  }
}

// MAPEAMENTO OTIMIZADO E ATUALIZADO COM L√ìGICA DOS VALORES - buildPropertiesSingleMedia
function buildPropertiesSingleMedia(row, dbProps) {
  const columnMap = {
    "ID": [propertieRichText, 0],
    "Longitude": [propertieRichText, 2],
    "Latitude": [propertieRichText, 3],
    "Regi√£o": [propertieSelect, 4],
    "Mesorregi√£o": [propertieRichText, 5],
    "UF": [propertieRichText, 6],
    "Pra√ßa": [propertieRichText, 7],
    "Emissora": [propertieTittle, 8],
    "Dial": [propertieRichText, 9],
    "Estilo musical": [propertieMultiSelect, 10],
    "G√™nero": [propertieRichTextAndAnnotation, 11, "pink"],
    "Classe": [propertieRichTextAndAnnotation, 12, "yellow"],
    "Idade": [propertieRichTextAndAnnotation, 13, "blue"],
    "Universo": [propertieNumber, 14],
    "Caixa comercial": [propertieRichTextCaixaComercial, 15],
    "PMM": [propertieNumber, 16],
    "Spots 30 ∫": [propertieNumber, 17],
    // L√ìGICA ESPECIAL: Corrigir valor da tabela se for > negociado ou vazio
    "Valor spot 30 ∫ (Tabela)": [propertieSpotTableValue, 18, 19], // 18=tabela, 19=negociado
    "Valor spot 30 ∫ (Negociado)": [propertieNumber, 19],
    "Test. 60 ∫": [propertieNumber, 20],
    // L√ìGICA ESPECIAL: Corrigir valor da tabela se for > negociado ou vazio
    "Valor test. 60 ∫ (Tabela)": [propertieTestimonialTableValue, 21, 22], // 21=tabela, 22=negociado
    "Valor test. 60 ∫ (Negociado)": [propertieNumber, 22],
    "Cach√™": [propertieNumber, 23],
    "Coment√°rios": [propertieRichText, 24],
    "Classifica√ß√£o": [propertieNumber, 25],
    "Classe AB": [propertieNumber, 37],
    "Classe C": [propertieNumber, 38],
    "Classe DE": [propertieNumber, 39],
    "Cobertura": [propertieCobertura, 40],
    "Data inicio": [propertieDate, "next_month_start"],
    "Data fim": [propertieDate, "next_month_end"], 
    "Dias da semana": [propertieWeekdays, "weekdays"],
    "KML": [propertieRichText, 41],
    // NOVAS PROPRIEDADES OTIMIZADAS
    "Target": [createTargetProperty, 42],
    "M√≠dia Kit": [createMediaKitLink, "media_kit"],
    "Facebook": [createFacebookLink, "facebook"],
    "Instagram": [createInstagramLink, "instagram"]
  };

  const properties = {};
  
  for (const [propName, config] of Object.entries(columnMap)) {
    if (!dbProps.includes(propName)) continue;

    const [func, colIndex, extraParam] = config;

    // Tratamento especial para as novas propriedades e l√≥gicas especiais
    if (propName === "Target") {
      const targetProp = createTargetProperty(row);
      if (targetProp.rich_text[0].text.content !== "") {
        properties[propName] = targetProp;
      }
    } else if (propName === "M√≠dia Kit") {
      const mediaKitLink = createMediaKitLink(row);
      if (mediaKitLink) {
        properties[propName] = mediaKitLink;
      }
    } else if (propName === "Facebook") {
      const facebookLink = createFacebookLink(row);
      if (facebookLink) {
        properties[propName] = facebookLink;
      }
    } else if (propName === "Instagram") {
      const instagramLink = createInstagramLink(row);
      if (instagramLink) {
        properties[propName] = instagramLink;
      }
    } else if (propName === "Valor spot 30 ∫ (Tabela)") {
      // L√≥gica especial: corrigir tabela (18) baseado no negociado (19)
      properties[propName] = propertieSpotTableValue(row, 18, 19);
    } else if (propName === "Valor test. 60 ∫ (Tabela)") {
      // L√≥gica especial: corrigir tabela (21) baseado no negociado (22)
      properties[propName] = propertieTestimonialTableValue(row, 21, 22);
    } else if (propName === "Data inicio" || propName === "Data fim" || propName === "Dias da semana") {
      properties[propName] = extraParam ? func(row, colIndex, extraParam) : func(row, colIndex);
    } else if (row.length > colIndex && row[colIndex] !== undefined && row[colIndex] !== "") {
      properties[propName] = extraParam ? func(row, colIndex, extraParam) : func(row, colIndex);
    }
  }

  return properties;
}

// buildPropertiesSponsorship ATUALIZADA COM L√ìGICAS DOS VALORES
function buildPropertiesSponsorship(row, headers, schema) {
  const properties = {};
  
  Object.keys(schema).forEach(propName => {
    // Campos calculados automaticamente
    if (propName === "Data inicio") {
      const dates = getNextMonthDates();
      properties[propName] = { date: { start: dates.start } };
      return;
    }
    
    if (propName === "Data fim") {
      const dates = getNextMonthDates();
      properties[propName] = { date: { start: dates.end } };
      return;
    }
    
    if (propName === "Dias da semana") {
      properties[propName] = {
        multi_select: [
          { name: "Seg." }, { name: "Ter." }, { name: "Qua." }, { name: "Qui." }, { name: "Sex." }
        ]
      };
      return;
    }

    // TRATAMENTO ESPECIAL PARA AS NOVAS PROPRIEDADES
    if (propName === "Target") {
      const targetProp = createTargetProperty(row);
      if (targetProp.rich_text[0].text.content !== "") {
        properties[propName] = targetProp;
      }
      return;
    }
    
    if (propName === "M√≠dia Kit") {
      const mediaKitLink = createMediaKitLink(row);
      if (mediaKitLink) {
        properties[propName] = mediaKitLink;
      }
      return;
    }
    
    if (propName === "Facebook") {
      const facebookLink = createFacebookLink(row);
      if (facebookLink) {
        properties[propName] = facebookLink;
      }
      return;
    }
    
    if (propName === "Instagram") {
      const instagramLink = createInstagramLink(row);
      if (instagramLink) {
        properties[propName] = instagramLink;
      }
      return;
    }

    // L√ìGICAS ESPECIAIS PARA VALORES DE SPOT E TESTIMONIAL
    if (propName === "Valor spot 30 ∫ (Tabela)") {
      const tableIndex = headers.indexOf(propName);
      const negotiatedIndex = headers.indexOf("Valor spot 30 ∫ (Negociado)");
      if (tableIndex !== -1 && negotiatedIndex !== -1) {
        properties[propName] = propertieSpotTableValue(row, tableIndex, negotiatedIndex);
      }
      return;
    }
    
    if (propName === "Valor test. 60 ∫ (Tabela)") {
      const tableIndex = headers.indexOf(propName);
      const negotiatedIndex = headers.indexOf("Valor test. 60 ∫ (Negociado)");
      if (tableIndex !== -1 && negotiatedIndex !== -1) {
        properties[propName] = propertieTestimonialTableValue(row, tableIndex, negotiatedIndex);
      }
      return;
    }

    // MAPEAMENTO DIRETO para coordenadas (n√£o depende do header)
    if (propName === "Longitude") {
      const value = row[2]; // Coluna C
      if (value !== undefined && value !== null && String(value).trim() !== "") {
        properties[propName] = { number: Number(value) };
      }
      return;
    }
    
    if (propName === "Latitude") {
      const value = row[3]; // Coluna D
      if (value !== undefined && value !== null && String(value).trim() !== "") {
        properties[propName] = { number: Number(value) };
      }
      return;
    }

    const colIndex = headers.indexOf(propName);
    if (colIndex === -1) return;

    const value = row[colIndex];
    if (value === undefined || value === null || String(value).trim() === "") return;

    // TRATAMENTO ESPECIAL para campo "Cobertura"
    if (propName === "Cobertura") {
      properties[propName] = propertieCobertura(row, colIndex);
      return;
    }

    // Criar propriedade baseada no tipo
    properties[propName] = createPropertyByType(schema[propName].type, value, propName);
  });

  return properties;
}

function createPropertyByType(type, value, propName) {
  const annotations = getAnnotationsByProperty(propName);
  
  switch (type) {
    case "title":
      return { title: [{ text: { content: String(value) } }] };
    case "rich_text":
      const content = truncateText(String(value), 2000);
      return { 
        rich_text: [{
          text: { content: content },
          annotations: annotations
        }]
      };
    case "number":
      return { number: Number(value) };
    case "select":
      return { select: { name: String(value) } };
    case "multi_select":
      const multiValue = String(value);
      const truncatedMulti = multiValue.length > 1900 ? truncateText(multiValue, 1900) : multiValue;
      return {
        multi_select: truncatedMulti.split(",").map(v => ({ name: v.trim() }))
      };
    case "date":
      return { date: { start: String(value) } };
    case "checkbox":
      return { checkbox: Boolean(value) };
    case "url":
      return { url: String(value) };
    default:
      const defaultContent = truncateText(String(value), 2000);
      return { rich_text: [{ text: { content: defaultContent } }] };
  }
}

function getAnnotationsByProperty(propName) {
  const annotationMap = {
    "G√™nero": { bold: true, color: "pink" },
    "Classe": { bold: true, color: "yellow" },
    "Idade": { bold: true, color: "blue" }
  };
  return annotationMap[propName] || {};
}

function getNextMonthDates() {
  const today = new Date();
  const nextMonth = new Date(today.getFullYear(), today.getMonth() + 1, 1);
  const lastDay = new Date(today.getFullYear(), today.getMonth() + 2, 0);
  
  const formatDate = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };
  
  return {
    start: formatDate(nextMonth),
    end: formatDate(lastDay)
  };
}

function propertieDate(row, type) {
  const dates = getNextMonthDates();
  if (type === "next_month_start") {
    return { date: { start: dates.start } };
  } else if (type === "next_month_end") {
    return { date: { start: dates.end } };
  }
}

function propertieWeekdays(row, type) {
  return {
    multi_select: [
      { name: "Seg." }, { name: "Ter." }, { name: "Qua." }, { name: "Qui." }, { name: "Sex." }
    ]
  };
}

// FUN√á√ïES LEGADAS MANTIDAS PARA COMPATIBILIDADE (agora super otimizadas)
function sendRowToNotionSingleMediaOptimized(row, token, databaseId, url, coverPath, headers) {
  const payload = preparePayloadSingleMedia(row, token, databaseId, headers);
  const response = UrlFetchApp.fetch(url, {
    method: "post",
    headers: { ...NOTION_CONFIG.headers, "Authorization": `Bearer ${token}` },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  });
  
  if (response.getResponseCode() < 400) {
    const data = JSON.parse(response.getContentText());
    if (data.id) {
      addRadioEmbedOnly(data.id, token, row);
    }
  }
}

function sendRowToNotionSponsorshipOptimized(row, token, databaseId, url, coverPath, headers) {
  const payload = preparePayloadSponsorship(row, token, databaseId, headers);
  const response = UrlFetchApp.fetch(url, {
    method: "post",
    headers: { ...NOTION_CONFIG.headers, "Authorization": `Bearer ${token}` },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  });
  
  if (response.getResponseCode() < 400) {
    const data = JSON.parse(response.getContentText());
    if (data.id) {
      addRadioEmbedOnly(data.id, token, row);
    }
  }
}

// Fun√ß√µes de compatibilidade atualizadas
function addExtraContentTurbo(pageId, token, row) {
  return addRadioEmbedOnly(pageId, token, row);
}

function addExtraContentOptimized(pageId, token, row) {
  return addRadioEmbedOnly(pageId, token, row);
}

function updatePageWithDistributionAndCoverageLinksOptimized(pageId, token) {
  Logger.log(`‚ö†Ô∏è Links agora s√£o gerados diretamente na tabela - p√°gina ${pageId}`);
}

function updatePageWithDistributionLinkOptimized(pageId, token) {
  updatePageWithDistributionAndCoverageLinksOptimized(pageId, token);
}

// clearPageCache j√° existe no arquivo "Editar P√°gina"
