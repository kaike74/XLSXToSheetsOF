// Cache global para evitar chamadas repetitivas √† API do Notion
const NOTION_CACHE = {
  dbProperties: new Map(),
  dbSchemas: new Map()
};

// Configura√ß√µes da API Notion otimizadas
const NOTION_CONFIG = {
  headers: {
    "Content-Type": "application/json",
    "Notion-Version": "2022-06-28"
  },
  baseUrl: "https://api.notion.com/v1"
};

function clearNotionDatabase(token, databaseId) {
  const queryUrl = `${NOTION_CONFIG.baseUrl}/databases/${databaseId}/query`;
  
  const headers = {
    ...NOTION_CONFIG.headers,
    "Authorization": `Bearer ${token}`
  };

  try {
    Logger.log("üóëÔ∏è Iniciando limpeza do database...");

    // Buscar todas as p√°ginas (pode precisar de m√∫ltiplas chamadas se > 100)
    let allPages = [];
    let hasMore = true;
    let nextCursor = null;

    while (hasMore) {
      const queryPayload = { page_size: 100 };
      if (nextCursor) {
        queryPayload.start_cursor = nextCursor;
      }

      const queryResponse = UrlFetchApp.fetch(queryUrl, {
        method: "post",
        headers: headers,
        payload: JSON.stringify(queryPayload),
        muteHttpExceptions: true
      });

      if (queryResponse.getResponseCode() !== 200) {
        Logger.log(`‚ùå Erro ao consultar database: ${queryResponse.getContentText()}`);
        return false;
      }

      const data = JSON.parse(queryResponse.getContentText());
      allPages = allPages.concat(data.results);
      
      hasMore = data.has_more;
      nextCursor = data.next_cursor;
      
      // Pequeno delay entre consultas
      if (hasMore) {
        Utilities.sleep(300);
      }
    }
    
    if (allPages.length === 0) {
      Logger.log("‚úÖ Database j√° est√° vazio");
      return true;
    }

    Logger.log(`üîÑ Arquivando ${allPages.length} p√°ginas...`);

    // Processar em lotes menores para garantir estabilidade
    const batchSize = 5; // Reduzido para maior estabilidade
    let archivedCount = 0;
    let errors = 0;

    for (let i = 0; i < allPages.length; i += batchSize) {
      const batch = allPages.slice(i, i + batchSize);
      
      // Processar cada p√°gina do lote sequencialmente
      for (const page of batch) {
        try {
          const response = UrlFetchApp.fetch(`${NOTION_CONFIG.baseUrl}/pages/${page.id}`, {
            method: "patch",
            headers: headers,
            payload: JSON.stringify({ archived: true }),
            muteHttpExceptions: true
          });

          if (response.getResponseCode() === 200) {
            archivedCount++;
          } else {
            errors++;
            Logger.log(`‚ö†Ô∏è Erro ao arquivar ${page.id}: ${response.getContentText()}`);
          }

          // Delay entre cada opera√ß√£o individual
          Utilities.sleep(150);

        } catch (error) {
          errors++;
          Logger.log(`‚ùå Erro ao arquivar p√°gina ${page.id}: ${error}`);
        }
      }
      
      // Log de progresso
      Logger.log(`üìä Progresso: ${Math.min(i + batchSize, allPages.length)}/${allPages.length} p√°ginas processadas`);
      
      // Delay maior entre lotes
      if (i + batchSize < allPages.length) {
        Utilities.sleep(500);
      }
    }

    Logger.log(`‚úÖ Limpeza conclu√≠da: ${archivedCount} arquivadas, ${errors} erros`);

    // Verifica√ß√£o final - aguardar um pouco e verificar se ainda existem p√°ginas
    Logger.log("üîç Verificando limpeza...");
    Utilities.sleep(2000); // Aguarda 2 segundos

    const verificationResponse = UrlFetchApp.fetch(queryUrl, {
      method: "post",
      headers: headers,
      payload: JSON.stringify({ page_size: 10 }),
      muteHttpExceptions: true
    });

    if (verificationResponse.getResponseCode() === 200) {
      const verificationData = JSON.parse(verificationResponse.getContentText());
      const remainingPages = verificationData.results.length;
      
      if (remainingPages > 0) {
        Logger.log(`‚ö†Ô∏è Ainda existem ${remainingPages} p√°ginas no database`);
        return false;
      } else {
        Logger.log("‚úÖ Database completamente limpo e verificado");
        return true;
      }
    }

    return archivedCount > 0 && errors === 0;

  } catch (error) {
    Logger.log(`‚ùå Erro cr√≠tico ao limpar database: ${error}`);
    return false;
  }
}

function exportDataToNotion(data, token, databaseId, url) {
  const headers = data[0];
  const exportType = data[1][33];

  // Pre-cache database properties
  if (exportType === "M√≠dia Avulsa") {
    getNotionDatabaseProperties(databaseId, token);
  } else if (exportType === "Patroc√≠nio") {
    getNotionDatabasePropertiesFull(databaseId, token);
  }

  // Processar em lotes para otimizar performance
  const batchSize = 5; // Reduzido para evitar timeout
  const batches = [];
  
  for (let i = 1; i < data.length; i += batchSize) {
    batches.push(data.slice(i, i + batchSize));
  }

  let processedCount = 0;
  
  batches.forEach((batch, batchIndex) => {
    batch.forEach((row, rowIndex) => {
      const actualIndex = batchIndex * batchSize + rowIndex + 1;
      
      try {
        if (exportType === "M√≠dia Avulsa") {
          sendRowToNotionSingleMediaOptimized(row, token, databaseId, url, row[31], headers);
        } else if (exportType === "Patroc√≠nio") {
          sendRowToNotionSponsorshipOptimized(row, token, databaseId, url, row[31], headers);
        }
        processedCount++;
      } catch (error) {
        Logger.log(`Erro ao processar linha ${actualIndex}: ${error}`);
      }
    });
    
    // Delay entre lotes para evitar rate limit
    if (batchIndex < batches.length - 1) {
      Utilities.sleep(300);
    }
    
    Logger.log(`Lote ${batchIndex + 1}/${batches.length} processado (${processedCount} registros)`);
  });
}

function sendRowToNotionSingleMediaOptimized(row, token, databaseId, url, coverPath, headers) {
  // URLs otimizadas
  const iconUrl = createImage(row, 27);
  const coverUrl = coverPath ? createImage(row, 31) : iconUrl;

  // Buscar propriedades do banco (com cache)
  const dbProps = getNotionDatabaseProperties(databaseId, token);
  
  // Mapeamento otimizado com valida√ß√£o de exist√™ncia
  const properties = buildPropertiesSingleMedia(row, dbProps);

  // Payload otimizado
  const notionPayload = {
    parent: { database_id: databaseId },
    cover: { type: "external", external: { url: coverUrl } },
    icon: { type: "external", external: { url: iconUrl } },
    properties: properties
  };

  // Enviar para Notion
  const response = sendToNotionAPI(url, token, notionPayload);
  
  if (response && response.id) {
    // Adicionar conte√∫do extra de forma ass√≠ncrona (otimizada)
    addExtraContentOptimized(response.id, token, row);
  }
}

function sendRowToNotionSponsorshipOptimized(row, token, databaseId, url, coverPath, headers) {
  const iconUrl = createImage(row, 27);
  const coverUrl = coverPath ? createImage(row, 31) : iconUrl;

  // Buscar schema do banco (com cache)
  const schema = getNotionDatabasePropertiesFull(databaseId, token);
  
  // Construir propriedades dinamicamente
  const properties = buildPropertiesSponsorship(row, headers, schema);

  const notionPayload = {
    parent: { database_id: databaseId },
    cover: { type: "external", external: { url: coverUrl } },
    icon: { type: "external", external: { url: iconUrl } },
    properties: properties
  };

  const response = sendToNotionAPI(url, token, notionPayload);
  
  if (response && response.id) {
    addExtraContentOptimized(response.id, token, row);
  }
}

// Fun√ß√£o auxiliar otimizada para buscar propriedades
function getNotionDatabaseProperties(databaseId, token) {
  if (NOTION_CACHE.dbProperties.has(databaseId)) {
    return NOTION_CACHE.dbProperties.get(databaseId);
  }

  try {
    const response = UrlFetchApp.fetch(`${NOTION_CONFIG.baseUrl}/databases/${databaseId}`, {
      method: "get",
      headers: {
        ...NOTION_CONFIG.headers,
        "Authorization": `Bearer ${token}`
      },
      muteHttpExceptions: true
    });

    const data = JSON.parse(response.getContentText());
    const properties = data.properties ? Object.keys(data.properties) : [];
    
    NOTION_CACHE.dbProperties.set(databaseId, properties);
    return properties;
  } catch (error) {
    Logger.log(`Erro ao buscar propriedades do database: ${error}`);
    return [];
  }
}

function getNotionDatabasePropertiesFull(databaseId, token) {
  if (NOTION_CACHE.dbSchemas.has(databaseId)) {
    return NOTION_CACHE.dbSchemas.get(databaseId);
  }

  try {
    const response = UrlFetchApp.fetch(`${NOTION_CONFIG.baseUrl}/databases/${databaseId}`, {
      method: "get",
      headers: {
        ...NOTION_CONFIG.headers,
        "Authorization": `Bearer ${token}`
      }
    });

    const data = JSON.parse(response.getContentText());
    if (!data.properties) {
      throw new Error("N√£o foi poss√≠vel obter o schema do banco do Notion");
    }

    NOTION_CACHE.dbSchemas.set(databaseId, data.properties);
    return data.properties;
  } catch (error) {
    Logger.log(`Erro ao buscar schema do database: ${error}`);
    return {};
  }
}

// FUN√á√ÉO CORRIGIDA: Agora inclui Longitude (coluna C=2) e Latitude (coluna D=3)
function buildPropertiesSingleMedia(row, dbProps) {
  const columnMap = {
    "ID": [propertieRichText, 0],
    "Longitude": [propertieRichText, 2], // ADICIONADO: Coluna C = √≠ndice 2
    "Latitude": [propertieRichText, 3],  // ADICIONADO: Coluna D = √≠ndice 3
    "Regi√£o": [propertieSelect, 4],
    "Mesorregi√£o": [propertieRichText, 5],
    "UF": [propertieRichText, 6],
    "Pra√ßa": [propertieRichText, 7],
    "Emissora": [propertieTittle, 8],
    "Dial": [propertieRichText, 9],
    "Estilo musical": [propertieMultiSelect, 10],
    "G√™nero": [propertieRichTextAndAnnotation, 11, "pink"],
    "Classe": [propertieRichTextAndAnnotation, 12, "yellow"],
    "Idade": [propertieRichTextAndAnnotation, 13, "blue"],
    "Universo": [propertieNumber, 14],
    "Caixa comercial": [propertieRichTextCaixaComercial, 15],
    "PMM": [propertieNumber, 16],
    "Spots 30 ∫": [propertieNumber, 17],
    "Valor spot 30 ∫ (Tabela)": [propertieNumber, 18],
    "Valor spot 30 ∫ (Negociado)": [propertieNumber, 19],
    "Test. 60 ∫": [propertieNumber, 20],
    "Valor test. 60 ∫ (Tabela)": [propertieNumber, 21],
    "Valor test. 60 ∫ (Negociado)": [propertieNumber, 22],
    "Cach√™": [propertieNumber, 23],
    "Coment√°rios": [propertieRichText, 24],
    "Classifica√ß√£o": [propertieNumber, 25],
    "Classe AB": [propertieNumber, 37],
    "Classe C": [propertieNumber, 38],
    "Classe DE": [propertieNumber, 39],
    "Cobertura": [propertieCobertura, 40],
    "Data inicio": [propertieDate, "next_month_start"],
    "Data fim": [propertieDate, "next_month_end"], 
    "Dias da semana": [propertieWeekdays, "weekdays"],
    "KML": [propertieRichText, 41],
  };

  const properties = {};
  
  for (const [propName, config] of Object.entries(columnMap)) {
    if (!dbProps.includes(propName)) continue;

    const [func, colIndex, extraParam] = config;

    if (propName === "Data inicio" || propName === "Data fim" || propName === "Dias da semana") {
      properties[propName] = extraParam ? func(row, colIndex, extraParam) : func(row, colIndex);
    } else if (row.length > colIndex && row[colIndex] !== undefined && row[colIndex] !== "") {
      properties[propName] = extraParam ? func(row, colIndex, extraParam) : func(row, colIndex);
    }
  }

  return properties;
}

// FUN√á√ÉO CORRIGIDA: Agora tamb√©m trata Longitude e Latitude no modo Patroc√≠nio
function buildPropertiesSponsorship(row, headers, schema) {
  const properties = {};
  
  Object.keys(schema).forEach(propName => {
    // Campos calculados automaticamente
    if (propName === "Data inicio") {
      const dates = getNextMonthDates();
      properties[propName] = { date: { start: dates.start } };
      return;
    }
    
    if (propName === "Data fim") {
      const dates = getNextMonthDates();
      properties[propName] = { date: { start: dates.end } };
      return;
    }
    
    if (propName === "Dias da semana") {
      properties[propName] = {
        multi_select: [
          { name: "Seg." }, { name: "Ter." }, { name: "Qua." }, { name: "Qui." }, { name: "Sex." }
        ]
      };
      return;
    }

    // MAPEAMENTO DIRETO para coordenadas (n√£o depende do header)
    if (propName === "Longitude") {
      const value = row[2]; // Coluna C
      if (value !== undefined && value !== null && String(value).trim() !== "") {
        properties[propName] = { number: Number(value) };
      }
      return;
    }
    
    if (propName === "Latitude") {
      const value = row[3]; // Coluna D
      if (value !== undefined && value !== null && String(value).trim() !== "") {
        properties[propName] = { number: Number(value) };
      }
      return;
    }

    const colIndex = headers.indexOf(propName);
    if (colIndex === -1) return;

    const value = row[colIndex];
    if (value === undefined || value === null || String(value).trim() === "") return;

    // TRATAMENTO ESPECIAL para campo "Cobertura"
    if (propName === "Cobertura") {
      properties[propName] = propertieCobertura(row, colIndex);
      return;
    }

    // Criar propriedade baseada no tipo
    properties[propName] = createPropertyByType(schema[propName].type, value, propName);
  });

  return properties;
}

// FUN√á√ÉO MODIFICADA: Agora com truncamento para textos longos
function createPropertyByType(type, value, propName) {
  const annotations = getAnnotationsByProperty(propName);
  
  switch (type) {
    case "title":
      return { title: [{ text: { content: String(value) } }] };
    case "rich_text":
      // Aplicar truncamento para rich_text
      const content = truncateText(String(value), 2000);
      return { 
        rich_text: [{
          text: { content: content },
          annotations: annotations
        }]
      };
    case "number":
      return { number: Number(value) };
    case "select":
      return { select: { name: String(value) } };
    case "multi_select":
      // Aplicar truncamento para multi_select se necess√°rio
      const multiValue = String(value);
      const truncatedMulti = multiValue.length > 1900 ? truncateText(multiValue, 1900) : multiValue;
      return {
        multi_select: truncatedMulti.split(",").map(v => ({ name: v.trim() }))
      };
    case "date":
      return { date: { start: String(value) } };
    case "checkbox":
      return { checkbox: Boolean(value) };
    case "url":
      return { url: String(value) };
    default:
      // Para tipos desconhecidos, usar rich_text com truncamento
      const defaultContent = truncateText(String(value), 2000);
      return { rich_text: [{ text: { content: defaultContent } }] };
  }
}

// Fun√ß√£o auxiliar para anota√ß√µes
function getAnnotationsByProperty(propName) {
  const annotationMap = {
    "G√™nero": { bold: true, color: "pink" },
    "Classe": { bold: true, color: "yellow" },
    "Idade": { bold: true, color: "blue" }
  };
  return annotationMap[propName] || {};
}

// Fun√ß√£o otimizada para envio √† API
function sendToNotionAPI(url, token, payload) {
  try {
    const response = UrlFetchApp.fetch(url, {
      method: "post",
      headers: {
        ...NOTION_CONFIG.headers,
        "Authorization": `Bearer ${token}`
      },
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });

    if (response.getResponseCode() >= 400) {
      Logger.log(`Erro HTTP ${response.getResponseCode()}: ${response.getContentText()}`);
      return null;
    }

    return JSON.parse(response.getContentText());
  } catch (error) {
    Logger.log(`Erro ao enviar para Notion: ${error}`);
    return null;
  }
}

// Fun√ß√£o otimizada para adicionar conte√∫do extra
function addExtraContentOptimized(pageId, token, row) {
  const urlApi = `${NOTION_CONFIG.baseUrl}/blocks/${pageId}/children`;
  
  // Executar opera√ß√µes em paralelo quando poss√≠vel
  const operations = [];
  
  if (row[28]) operations.push(() => addFileToNotionPageOptimized(urlApi, row[28], token));
  if (row[29]) operations.push(() => addLinkToPageContentOptimized(token, urlApi, row, "row[29]"));
  if (row[30]) operations.push(() => addLinkToPageContentOptimized(token, urlApi, row, "row[30]"));
  if (row[35]) operations.push(() => addLinkToNotionPageOptimized(urlApi, row, 35, token));
  
  // Executar opera√ß√µes com pequeno delay entre elas
  operations.forEach((operation, index) => {
    try {
      operation();
      if (index < operations.length - 1) {
        Utilities.sleep(100);
      }
    } catch (error) {
      Logger.log(`Erro em opera√ß√£o extra ${index}: ${error}`);
    }
  });
  
  // Adicionar links de distribui√ß√£o E cobertura
  updatePageWithDistributionAndCoverageLinksOptimized(pageId, token);
}

// Vers√µes otimizadas das fun√ß√µes de conte√∫do extra (funcionalidade completa)
function addFileToNotionPageOptimized(urlApi, filePath, token) {
  if (!filePath) return;
  
  const fileName = filePath.split("/").pop();
  const fileId = getFileIdByName(fileName);

  if (!fileId) {
    Logger.log(`Arquivo n√£o encontrado: ${fileName}`);
    return;
  }

  const driveUrl = `https://drive.google.com/file/d/${fileId}/view?usp=drive_link`;

  const blocksPayload = {
    children: [{
      type: "callout", 
      callout: {
        icon: { type: "emoji", emoji: "üñáÔ∏è" },
        rich_text: [{
          type: "text",
          text: { content: "MIDIA KIT" },
          annotations: { bold: true }
        }],
        children: [{
          type: "file", 
          file: {
            external: { url: driveUrl },
            name: "M√≠dia Kit"
          }
        }]
      }
    }]
  };

  try {
    const response = UrlFetchApp.fetch(urlApi, {
      method: "patch",
      headers: {
        ...NOTION_CONFIG.headers,
        "Authorization": `Bearer ${token}`
      },
      payload: JSON.stringify(blocksPayload),
      muteHttpExceptions: true
    });

    if (response.getResponseCode() >= 400) {
      Logger.log(`Erro ao adicionar arquivo: ${response.getContentText()}`);
    }
  } catch (error) {
    Logger.log(`Erro ao adicionar arquivo √† p√°gina: ${error}`);
  }
}

function addLinkToPageContentOptimized(token, urlApi, row, column) {
  let socialMediaLink, media, urlIcon, path;

  if (column === "row[30]") {
    socialMediaLink = "https://www.instagram.com/";
    media = "Instagram";
    urlIcon = "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1200px-Instagram_icon.png";
    path = row[30];
  } else if (column === "row[29]") {
    socialMediaLink = "https://www.facebook.com/";
    media = "Facebook";
    urlIcon = "https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/Facebook_icon_2013.svg/2048px-Facebook_icon_2013.svg.png";
    path = row[29];
  } else {
    return;
  }

  if (!path) return;

  const socialMediaParametro = processSocialMediaLink(path, row);
  if (!socialMediaParametro) return;

  socialMediaLink += socialMediaParametro;

  const payload = {
    children: [{
      object: "block",
      type: "callout",
      callout: {
        icon: {
          type: "external",
          external: { url: urlIcon }
        },
        rich_text: [{
          type: "text",
          text: {
            content: `${media} | R√°dio ${row[8]} - ${row[9]}`,
            link: { url: socialMediaLink }
          },
          annotations: { bold: true }
        }]
      }
    }]
  };

  try {
    const response = UrlFetchApp.fetch(urlApi, {
      method: "PATCH",
      headers: {
        ...NOTION_CONFIG.headers,
        "Authorization": `Bearer ${token}`
      },
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });

    if (response.getResponseCode() >= 400) {
      Logger.log(`Erro ao adicionar link ${media}: ${response.getContentText()}`);
    }
  } catch (error) {
    Logger.log(`Erro ao adicionar link ${media}: ${error}`);
  }
}

function addLinkToNotionPageOptimized(urlApi, row, index, token) {
  const radioLink = row[index];

  if (!radioLink || radioLink.length === 0 || !radioLink.includes("apption.co")) {
    return;
  }

  const blocksPayload = {
    children: [{
      object: "block",
      type: "embed",
      embed: { url: radioLink }
    }]
  };

  try {
    const response = UrlFetchApp.fetch(urlApi, {
      method: "patch",
      headers: {
        ...NOTION_CONFIG.headers,
        "Authorization": `Bearer ${token}`
      },
      payload: JSON.stringify(blocksPayload),
      muteHttpExceptions: true
    });

    if (response.getResponseCode() >= 400) {
      Logger.log(`Erro ao adicionar embed de r√°dio: ${response.getContentText()}`);
    }
  } catch (error) {
    Logger.log(`Erro ao adicionar embed √† p√°gina: ${error}`);
  }
}

// FUN√á√ÉO SIMPLIFICADA: Compat√≠vel, mas n√£o atualiza links (agora feitos por f√≥rmula)
function updatePageWithDistributionAndCoverageLinksOptimized(pageId, token) {
  // A fun√ß√£o foi mantida para compatibilidade, mas n√£o altera nada
  Logger.log(`‚ö†Ô∏è updatePageWithDistributionAndCoverageLinksOptimized chamada para a p√°gina ${pageId}, mas os links agora s√£o gerados por f√≥rmulas.`);
}


// FUN√á√ÉO MANTIDA PARA COMPATIBILIDADE (chama a nova fun√ß√£o)
function updatePageWithDistributionLinkOptimized(pageId, token) {
  updatePageWithDistributionAndCoverageLinksOptimized(pageId, token);
}

// Fun√ß√µes auxiliares mantidas
function getNextMonthDates() {
  const today = new Date();
  const nextMonth = new Date(today.getFullYear(), today.getMonth() + 1, 1);
  const lastDay = new Date(today.getFullYear(), today.getMonth() + 2, 0);
  
  const formatDate = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };
  
  return {
    start: formatDate(nextMonth),
    end: formatDate(lastDay)
  };
}

function propertieDate(row, type) {
  const dates = getNextMonthDates();
  if (type === "next_month_start") {
    return { date: { start: dates.start } };
  } else if (type === "next_month_end") {
    return { date: { start: dates.end } };
  }
}

function propertieWeekdays(row, type) {
  return {
    multi_select: [
      { name: "Seg." }, { name: "Ter." }, { name: "Qua." }, { name: "Qui." }, { name: "Sex." }
    ]
  };
}
