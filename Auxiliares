// Cache para otimizar operações repetitivas
const CACHE = {
  fileIds: new Map(),
  processedUrls: new Map(),
  dateTime: null,
  dateTimeExpiry: 0
};

// Constantes para evitar recriação
const BASE_IMAGE_URL = 'https://www.appsheet.com/image/getimageurl?appName=E-R%C3%A1dios-408183446-24-03-22-2';
const SIGNATURE_IMAGE = 'a107f1dc96a649316127fec7b49d24ce2c7a224625d288be3423631f42d8ea3f';
const SIGNATURE_COVER = '9b91074fbffb5c9c28db76c102ad644c0114e92ce5950732557d9113762752a8';
const VERSION_RADIOS = '1.002203';
const VERSION_CLIENTES = '1.001749';

// NOVA FUNÇÃO: Truncamento inteligente para textos longos
function truncateText(text, maxLength = 2000) {
  if (!text || typeof text !== 'string') return '';
  
  // Se o texto é menor que o limite, retorna como está
  if (text.length <= maxLength) return text;
  
  // Reserva espaço para o indicador de truncamento
  const truncateIndicator = "... [TEXTO TRUNCADO - Ver site para conteúdo completo]";
  const availableLength = maxLength - truncateIndicator.length;
  
  // Tenta cortar em uma quebra de palavra para não cortar no meio
  let truncated = text.substring(0, availableLength);
  const lastSpaceIndex = truncated.lastIndexOf(' ');
  
  // Se encontrou um espaço nos últimos 50 caracteres, corta ali
  if (lastSpaceIndex > availableLength - 50) {
    truncated = truncated.substring(0, lastSpaceIndex);
  }
  
  return truncated + truncateIndicator;
}

function getNotionDataBaseId(url) {
  // Cache para URLs já processadas
  if (CACHE.processedUrls.has(url)) {
    return CACHE.processedUrls.get(url);
  }
  
  const match = url.match(/e-radios\/(.*?)\?/);
  const result = match ? match[1] : null;
  
  CACHE.processedUrls.set(url, result);
  return result;
}

function createImage(row, index) {
  // Evita encodeURIComponent desnecessário se já estiver encodado
  const fileName = row[index];
  if (!fileName) return '';
  
  return `${BASE_IMAGE_URL}&tableName=R%C3%A1dios%202&fileName=${encodeURIComponent(fileName)}&appVersion=${VERSION_RADIOS}&signature=${SIGNATURE_IMAGE}`;
}

function createCover(row, index) {
  const fileName = row[index];
  if (!fileName) return '';
  
  return `${BASE_IMAGE_URL}&tableName=R%C3%A1dios%202&fileName=${encodeURIComponent(fileName)}&appVersion=${VERSION_RADIOS}&signature=${SIGNATURE_COVER}`;
}

function createPageIcon(row) {
  if (!row || !row.includes('::')) return '';
  
  const [prefix, filePath] = row.split('::');
  return `${BASE_IMAGE_URL}&tableName=Clientes&fileName=${encodeURIComponent(filePath)}&appVersion=${VERSION_CLIENTES}&`;
}

function createIcon(row, index) {
  const fileName = row[index];
  if (!fileName) return '';
  
  const link = `${BASE_IMAGE_URL}&tableName=R%C3%A1dios%202&fileName=${encodeURIComponent(fileName)}&appVersion=${VERSION_RADIOS}&signature=${SIGNATURE_COVER}`;
  
  // Otimização: usar replace encadeado ao invés de múltiplos replace
  return link
    .replace(/[&<>"']/g, function(match) {
      const escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&apos;'
      };
      return escapeMap[match];
    });
}

// Cache para IDs de arquivos já buscados
function getFileIdByName(fileName) {
  if (!fileName) return null;
  
  // Verifica cache primeiro
  if (CACHE.fileIds.has(fileName)) {
    return CACHE.fileIds.get(fileName);
  }
  
  try {
    const files = DriveApp.getFilesByName(fileName);
    const fileId = files.hasNext() ? files.next().getId() : null;
    
    // Armazena no cache
    CACHE.fileIds.set(fileName, fileId);
    return fileId;
  } catch (error) {
    // Log apenas em caso de erro
    Logger.log(`Erro ao buscar arquivo ${fileName}: ${error}`);
    return null;
  }
}

function removeEspacosExtras(str) {
  if (!str || typeof str !== 'string') return '';
  
  // Otimização: usar uma única operação de regex
  return str.replace(/\s+/g, ' ').trim();
}

function dateTimeFunction() {
  const now = Date.now();
  
  // Cache de 1 minuto para evitar recálculos desnecessários
  if (CACHE.dateTime && now < CACHE.dateTimeExpiry) {
    return CACHE.dateTime;
  }
  
  const currentDate = new Date();
  
  // Usar padStart é mais eficiente que concatenação de strings
  const day = String(currentDate.getDate()).padStart(2, '0');
  const month = String(currentDate.getMonth() + 1).padStart(2, '0');
  const hour = String(currentDate.getHours()).padStart(2, '0');
  const minutes = String(currentDate.getMinutes()).padStart(2, '0');
  
  const dateTime = `${day}/${month} - ${hour}:${minutes}`;
  
  // Atualiza cache (válido por 1 minuto)
  CACHE.dateTime = dateTime;
  CACHE.dateTimeExpiry = now + 60000;
  
  return dateTime;
}

function processSocialMediaLink(url, row) {
  if (!url) return null;
  
  // Cache para URLs já processadas
  const cacheKey = `${url}_${row[7]}_${row[8]}`;
  if (CACHE.processedUrls.has(cacheKey)) {
    return CACHE.processedUrls.get(cacheKey);
  }
  
  try {
    // Remove protocolo uma única vez
    let cleanUrl = url.replace(/^https?:\/\//, '');
    let result = null;
    
    if (cleanUrl.includes("instagram") || cleanUrl.includes("facebook")) {
      const match = cleanUrl.match(/(?:www\.)?(?:facebook|instagram)\.com\/([^\/?]+)/);
      result = match && match[1] ? match[1] : null;
    } else {
      const match = cleanUrl.match(/^([^\/?]+)/);
      result = match && match[1] ? match[1] : cleanUrl || null;
    }
    
    // Cache o resultado
    CACHE.processedUrls.set(cacheKey, result);
    
    // Log apenas em caso de erro
    if (!result) {
      Logger.log(`Rádio ${row[7]} ${row[8]}: URL inválido ou não encontrado.`);
    }
    
    return result;
  } catch (error) {
    Logger.log(`Erro ao processar URL: ${error}`);
    return null;
  }
}

// Otimização: usar objetos pré-construídos para evitar recriação
function propertieSelect(row, index) {
  const value = row[index];
  return value ? { "select": { "name": String(value) } } : { "select": null };
}

function propertieRichTextCaixaComercial(row, index) {
  const value = row[index];
  
  if (!value || value <= 0) {
    return { "rich_text": [{ "text": { "content": "" } }] };
  }
  
  return { "rich_text": [{ "text": { "content": `${value} min` } }] };
}

function propertieTittle(row, index) {
  return { "title": [{ "text": { "content": String(row[index] || '') } }] };
}

function propertieNumber(row, index) {
  const value = row[index];
  return { "number": value ? Number(value) : null };
}

// FUNÇÃO MODIFICADA: Agora com truncamento para textos longos
function propertieRichText(row, index) {
  let content = String(row[index] || '');
  
  // Aplicar truncamento se o texto for muito longo
  content = truncateText(content, 2000);
  
  return { "rich_text": [{ "text": { "content": content } }] };
}

// FUNÇÃO MODIFICADA: Agora com truncamento para textos longos
function propertieRichTextAndAnnotation(row, index, cor) {
  let content = String(row[index] || '');
  
  // Aplicar truncamento se o texto for muito longo
  content = truncateText(content, 2000);
  
  return {
    "rich_text": [{
      "text": { "content": content },
      "annotations": { "bold": true, "color": cor }
    }]
  };
}

// FUNÇÃO MODIFICADA: Agora com truncamento para multi-select com textos longos
function propertieMultiSelect(row, index) {
  const value = row[index];
  
  if (!value || String(value).trim() === "") {
    return { "multi_select": [] };
  }
  
  // Converter para string e verificar se é muito longo
  let stringValue = String(value);
  
  // Se o valor total for muito longo, truncar antes de processar
  if (stringValue.length > 1900) { // Margem de segurança para multi-select
    stringValue = truncateText(stringValue, 1900);
  }
  
  // Otimização: processar uma única vez
  const values = stringValue
    .split(',')
    .map(item => item.trim())
    .filter(item => item) // Remove itens vazios
    .map(value => {
      // Cada item do multi-select também tem limite
      const truncatedValue = value.length > 100 ? value.substring(0, 97) + "..." : value;
      return { "name": truncatedValue };
    });
  
  return { "multi_select": values };
}

// NOVA FUNÇÃO: Específica para campo Cobertura (pode ser rich_text ou multi_select)
function propertieCobertura(row, index) {
  const value = row[index];
  
  if (!value || String(value).trim() === "") {
    return { "rich_text": [{ "text": { "content": "" } }] };
  }
  
  // Sempre trata como rich_text e aplica truncamento
  const content = truncateText(String(value), 2000);
  
  return { "rich_text": [{ "text": { "content": content } }] };
}

// Função para limpar cache quando necessário (opcional)
function clearCache() {
  CACHE.fileIds.clear();
  CACHE.processedUrls.clear();
  CACHE.dateTime = null;
  CACHE.dateTimeExpiry = 0;
}
